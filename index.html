<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/blog/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/blog/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/blog/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/blog/favicon.ico?v=0.5.0" />






<meta name="description" content="眼睛和大脑">
<meta property="og:type" content="website">
<meta property="og:title" content="刘定源's blog">
<meta property="og:url" content="http://liudyuan.com/blog/index.html">
<meta property="og:site_name" content="刘定源's blog">
<meta property="og:description" content="眼睛和大脑">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="刘定源's blog">
<meta name="twitter:description" content="眼睛和大脑">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 6271364299969529000,
      author: '博主'
    }
  };
</script>

  <title> 刘定源's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?42b466e32fbb87785dd2df18b00c5612";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/blog/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">刘定源's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/blog/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/blog/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2016/06/17/高性能JavaScript-01加载和执行/" itemprop="url">
                  高性能JavaScript(一)加载和执行
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-17T21:55:32+08:00" content="2016-06-17">
              2016-06-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/blog/categories/笔记/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/blog/2016/06/17/高性能JavaScript-01加载和执行/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/17/高性能JavaScript-01加载和执行/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="脚本位置"><a href="#脚本位置" class="headerlink" title="脚本位置"></a>脚本位置</h2><p><code>&lt;script&gt;</code>标签可以放在<code>&lt;head&gt;</code>和<code>&lt;body&gt;</code>中，推荐尽量放在<code>&lt;body&gt;</code>底部(<code>&lt;/body&gt;</code>前)。</p>
<p>原因：浏览器在解析到<code>&lt;script&gt;</code>时，会下载脚本文件并执行，在这个过程中浏览器不会渲染页面。这会造成一个很明显的性能问题：脚本阻塞页面渲染。浏览器页面很可能一片空白，用户无法和页面进行交互。尽管现在浏览器都允许并行下载文件，一定程度上提高了性能，但页面渲染依然需要等待所有脚本执行完毕后才继续进行。</p>
<h2 id="组织脚本"><a href="#组织脚本" class="headerlink" title="组织脚本"></a>组织脚本</h2><p>减少页面脚本数量可以改善性能。如果需要依赖多个脚本文件，可以将多个文件合并为一个(打包工具)。</p>
<p>原因：脚本的下载和执行需要时间，再加上http请求带来的额外开销(下载一个100kb文件比下载4个25kb文件更快)。脚本文件越多越影响性能。</p>
<h2 id="无阻塞脚本"><a href="#无阻塞脚本" class="headerlink" title="无阻塞脚本"></a>无阻塞脚本</h2><p>web应用越复杂，需要的js代码就越多，合并后的单个js文件越大，阻塞浏览器的时间越长。需要一个更好的方法解决这个问题，比如逐步加载js文件，在页面加载完成后才加载js文件。</p>
<ol>
<li><p>延迟脚本</p>
<p>HTML4给<code>&lt;script&gt;</code>定义了一个defer属性(HTML5 增加了async)。浏览器解析到<code>&lt;script&gt;</code>时会开始下载脚本，但不会执行，直到页面加载完成(onload事件被触发前)。看个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script defer&gt;</span><br><span class="line">        alert(&apos;defer&apos;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        alert(&apos;script&apos;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        window.onload = function() &#123;</span><br><span class="line">            alert(&apos;load&apos;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>浏览器依次弹出：script,defer,load。</p>
</li>
<li><p>动态脚本元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function loadScript(url, callback) &#123;</span><br><span class="line">  var script = document.createElement(&apos;script&apos;);</span><br><span class="line">  </span><br><span class="line">  if (script.readyState) &#123;  //for IE</span><br><span class="line">      script.onreadyStateChange = function() &#123;</span><br><span class="line">          if (script.readyState === &apos;loaded&apos; || script.readyState === &apos;complete&apos;) &#123;</span><br><span class="line">              script.onreadyStateChange = null;</span><br><span class="line">              callback();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">      script.onload = function() &#123;</span><br><span class="line">          callback();</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  script.src = url;</span><br><span class="line">  document.head.appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想要按顺序加载多个文件，可以这样使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loadScript(&apos;file1.js&apos;,function() &#123;</span><br><span class="line">  loadScript(&apos;file2.js&apos;,function() &#123;</span><br><span class="line">  loadScript(&apos;file3.js&apos;,fonction() &#123;&#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当然，最好是将多个js文件合并为一个(此时是异步的,单个大文件不会有影响)。</p>
</li>
<li><p>XMLHttpRequest脚本注入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var request = new XMLHttpRequest();</span><br><span class="line">request.onreadyStateChange = function() &#123;</span><br><span class="line">  if (request.readyState === 4) &#123;</span><br><span class="line">      if(request.state &gt;= 200 &amp;&amp; request.state &lt; 300 || request.state === 304) &#123;</span><br><span class="line">          var script = document.createElement(&apos;script&apos;);</span><br><span class="line">          script.text = request.responseText;</span><br><span class="line">          document.head.addendChild(script);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">request.open(&apos;get&apos;,&apos;file.js&apos;);</span><br><span class="line">request.send();</span><br></pre></td></tr></table></figure>
<p>就是用AJAX加载的内联脚本，一旦添加立刻执行，但受到浏览器同源策略限制。</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>浏览器解析到<code>&lt;script&gt;</code>时会下载js文件并执行，这个过程会阻塞浏览器运行其他任务(比如页面的渲染)。</p>
<p>提高性能的几种方法：</p>
<ol>
<li><p>将<code>&lt;script&gt;</code>放在<code>&lt;/body&gt;</code>前。在脚本执行前页面已完成渲染。</p>
</li>
<li><p>合并多个js文件。减少http请求。</p>
</li>
<li><p>无阻塞下载js文件</p>
<p>a. defer、async</p>
<p>b. 动态添加</p>
<p>c. AJAX</p>
</li>
</ol>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2016/06/14/JavaScript作用域学习笔记/" itemprop="url">
                  JavaScript作用域学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-14T21:59:23+08:00" content="2016-06-14">
              2016-06-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/blog/categories/笔记/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/blog/2016/06/14/JavaScript作用域学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/14/JavaScript作用域学习笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="抛砖引玉"><a href="#抛砖引玉" class="headerlink" title="抛砖引玉"></a>抛砖引玉</h2><pre><code>var name = &apos;ldy&apos;;
function echo() {
    console.log(name);
    var name = &apos;hello&apos;;
    console.log(name);
    console.log(age);
}

echo()
</code></pre><p>一不注意可能以为结果是这样的：</p>
<pre><code>ldy
hello
出错
</code></pre><p>第一次输出name取到的是全局变量name的值，所以输出ldy，接着name的值被局部变量name覆盖，所以输出hello，最后age没有定义，所以抛错。</p>
<p>但实际上结果是这样的：</p>
<pre><code>undefined
hello
出错
</code></pre><h2 id="JavaScript的作用域链"><a href="#JavaScript的作用域链" class="headerlink" title="JavaScript的作用域链"></a>JavaScript的作用域链</h2><p>ECMA262描述：</p>
<blockquote>
<ul>
<li>任何执行上下文时刻的作用域，都是由作用域链(scope chain)来实现</li>
<li>在一个函数被定义的时候，会将它定义时刻的scope chain链接到这个函数对象的[[scope]]属性</li>
<li>在一个函数对象被调用的时候，会创建一个活动对象，然后对每一个函数的形参，都命名为该活动对象的命名属性，然后将这个活动对象作为此时的作用域链(scope chain)最前端，并将这个函数对象的[[scope]]加入到scope chain中</li>
</ul>
</blockquote>
<p>通过一个例子说明一下这个过程：</p>
<pre><code>var foo = function(arg1,arg2) {
    var name = &apos;ldy&apos;;
}

foo();
</code></pre><ol>
<li><p>在定义foo时，会创建这个函数对象的[[scope]]属性，并将这个[[scope]]属性链接到定义它的作用域链上，此时因为foo定义在全局环境，所以此时的[[scope]]指向全局活动对象window active object</p>
</li>
<li><p>在调用foo时，会创建一个活动对象，并创建arguments属性，然后给这个对象添加两个命名属性arg1，arg2；对于每一个在这个函数中声明的局部变量和函数定义，都作为该活动对象的同名命名属性</p>
</li>
<li><p>将调用参数赋值给形式参数，对于缺少的调用参数，赋值为undefined</p>
</li>
<li><p>将这个活动对象作为scope chain的最前端，并将foo的[[scope]]属性所指向的，定义foo时创建的顶级活动对象加入到scope chain</p>
</li>
</ol>
<p>通过这个作用域链，在发生标识符解析的时候，就会逆向查询当前作用域链列表的每一个活动对象的属性，如果找到同名就返回，找不到就是为定义。</p>
<p>函数对象的[[scope]]属性是在函数被定义的时候决定的，不是在调用的时候。于是：</p>
<pre><code>var name = &apos;ldy&apos;;

function echo() {
    console.log(name);
}   

function foo() {
    var name = &apos;hello&apos;;
    echo();
}

foo();//ldy
</code></pre><p>综合以上，详解一个例子：</p>
<pre><code>function factory() {
    var name = &apos;ldy&apos;;
    var intro = function() {
        console.log(&apos;I am &apos;+name);
    }
    return intro;
}

function app(para) {
    var name = para;
    var func = factory();
    func();
}

app(&apos;eve&apos;);//I am ldy
</code></pre><p>调用app时，scope chain:{window活动对象(全局)}-&gt;{app活动对象}</p>
<p>在刚进入app函数体时，app的活动对象有一个arguments属性，值为undefined的两个属性:name、func,值为’eve’的属性para</p>
<p>此时的scope chain：</p>
<pre><code>[[scope chain]] = [
    {
        para: &apos;eve&apos;,
        name: undefined,
        func: undefined,
        arguments: []
    },
    {
        window call object
    }
]
</code></pre><p>当调用进入factory的函数体的时候，此时factory的scope chain：</p>
<pre><code>[[scope chain]] = [
    {
        name: undefined,
        intro: undefined
    },
    {
        window call object
    }
]
</code></pre><p>此时的作用域链中并不包含app的活动对象。</p>
<p>定义intro函数时，intro函数的[[scope]]为：<br>    [[scope chain]] = [<br>        {<br>            name: ‘ldy’;<br>            intro: undefined<br>        },<br>        {<br>            window call object<br>        }<br>    ]</p>
<p>从factory函数返回后，在app内调用intro的时候，发生了标识符解析，此时：</p>
<pre><code>[[scope chain]] = [
    {
        intro call object
    },
    {
        name: &apos;ldy&apos;,
        intro: undefined
    },
    {
        window call object
    }
]
</code></pre><p>因为scope chain中不包含factory活动对象，name标识符解析的结果应该是factory活动对象中的name属性，也就是’ldy’。</p>
<h2 id="JavaScriptd的预编译"><a href="#JavaScriptd的预编译" class="headerlink" title="JavaScriptd的预编译"></a>JavaScriptd的预编译</h2><p>js是一种脚本语言，js的执行过程，是一种翻译执行的过程。</p>
<p>在js中有预编译过程，在执行每一段js代码之前，都会首先处理var关键字和function定义式。在调用函数执行之前，会首先创建一个活动对象，然后搜寻这个函数中的局部变量定义和函数定义，将变量名函数名都作为这个活动对象的同名属性，对于局部变量定义，变量的值会在真正执行的时候才计算，此时只是简单的赋为undefined</p>
<hr>
<p>笔记来源： <a href="http://www.laruence.com/2009/05/28/863.html" target="_blank" rel="external">鸟哥：Javascript作用域原理</a></p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2016/05/22/JS中的克隆/" itemprop="url">
                  JS中的克隆
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-22T18:20:08+08:00" content="2016-05-22">
              2016-05-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/blog/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/blog/2016/05/22/JS中的克隆/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/22/JS中的克隆/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>javascript有五种简单数据类型(基本数据类型)：Null、Undefined、Number、String，Boolean,一种复杂数据类型：Object。</p>
<p>javascript变量包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值按引用访问，引用类型值按引用访问（为对象添加属性操作的是实际对象）</p>
<h2 id="Number类型的值克隆"><a href="#Number类型的值克隆" class="headerlink" title="Number类型的值克隆"></a>Number类型的值克隆</h2><pre><code>var a=1;
var b=a;
a=2;

console.log(a);//2
console.log(b);//1
</code></pre><h2 id="String类型的值克隆"><a href="#String类型的值克隆" class="headerlink" title="String类型的值克隆"></a>String类型的值克隆</h2><pre><code>var a=&apos;x&apos;;
var b=a;
a=&apos;y&apos;;

console.log(a);//&apos;y&apos;
console.log(b);//&apos;x&apos;
</code></pre><h2 id="Boolean类型的值克隆"><a href="#Boolean类型的值克隆" class="headerlink" title="Boolean类型的值克隆"></a>Boolean类型的值克隆</h2><pre><code>var a=true;
var b=a;
a=false;

console.log(a)//false
console.log(b)//true
</code></pre><h2 id="Object类型的值克隆"><a href="#Object类型的值克隆" class="headerlink" title="Object类型的值克隆"></a>Object类型的值克隆</h2><pre><code>var obj={
    a: 1,
    b: {
        b1: [&quot;hello&quot;,&quot;world&quot;],
        b2: &quot;javascript&quot;
    }
}
var newObj=obj;
obj.a=2;

console.log(obj.a);//2
console.log(newObj.a);//2
</code></pre><p>由以上可得出结论：简单数据类型的值克隆实际上是复制了新的数据给变量，此时已经是两个不同的变量，操作其中一个变量不会影响到另一个变量；与此不同的是，Object类型的值克隆实际上并没有复制一份新的数据，只是将新变量指向了原来的对象，相当于两个变量共享一个对象。这就造成了一个问题，操作其中一个变量将会影响另一个变量。怎样才能真正的克隆对象，得到一个新的与原来毫不相干的对象呢？可以自定义一个函数，实现真正的完整克隆。</p>
<h2 id="完整的对象克隆"><a href="#完整的对象克隆" class="headerlink" title="完整的对象克隆"></a>完整的对象克隆</h2><pre><code>function cloneObject(src){
var obj,i;
if (typeof src !==&quot;object&quot;||src===null) {return src;}
if (src.constructor===Array) {
    obj=[];
    for(i=0;i&lt;src.length;i++){
        if (typeof src[i]===&quot;object&quot;) {
            obj[i]=arguments.callee(src[i]);
        }
        else{
            obj[i]=src[i];
        }
    }
}
else{
    obj={};
    for(i in src){
        if (typeof obj[i]===&quot;object&quot;) {
            obj[i]=arguments.callee(src[i]);
        }
        else{
            obj[i]=src[i];
        }
    }
}
return obj;
}
</code></pre><p>其中用到了递归，实现了对象的深度复制。</p>
<p>另一种好像很优雅的写法:</p>
<pre><code>function clone(src){
var str,obj=src.constructor===Array?[]:{};
if (typeof src !==&quot;object&quot;){
    return src;
}
else if(window.JSON){
    str=JSON.stringify(src);
    obj=JSON.parse(str);
}
else{
    for(var i in src){
        obj[i]=typeof src[i]===&quot;object&quot;?arguments.callee(src[i]):src[i];
    }
}
return obj;
}
</code></pre><p>JSON.string()将对象转化成字符串，JSON.parse()将字符串还原成对象。通过这种方法实现对象的深度复制。低版本浏览器就用遍历和递归。</p>
<hr>
<p>参考：<a href="http://sentsin.com/web/21.html" target="_blank" rel="external">也谈JavaScript对象之深度克隆</a></p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2016/05/07/head标签/" itemprop="url">
                  HTML head标签
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-07T16:20:53+08:00" content="2016-05-07">
              2016-05-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/blog/categories/html/" itemprop="url" rel="index">
                    <span itemprop="name">html</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/blog/2016/05/07/head标签/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/07/head标签/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="DOCTYPE"><a href="#DOCTYPE" class="headerlink" title="DOCTYPE"></a>DOCTYPE</h2><p>DOCTYPE声明告知浏览器使用哪种HTML或者XHTML规范。</p>
<p>DTD(Document Type Definition)申明以&lt;!DOCTYPE&gt;开始，不区分大小写，前面没有任何内容，如果有其他内容（空格除外）会使浏览器在IE下开启怪异模式渲染网页。公共DTD，名称格式为注册//组织//类型 标签//语言，注册指组织是否由国际标准化组织(ISO)注册，+表示是，-表示不是。类型一般是DTD。标签是指定公开文本描述，即对所引用的公开文本的唯一描述性名称，后面可附带版本号。最后语言是 DTD 语言的 ISO 639 语言标识符，如：EN 表示英文，ZH 表示中文。XHTML 1.0 可声明三种 DTD 类型。分别表示严格版本，过渡版本，以及基于框架的 HTML 文档。</p>
<p>HTML 4.01 strict</p>
<pre><code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;&quot;http://www.w3.org/TR/html4/strict.dtd&gt;
</code></pre><p>HTML 4.01 Transitional</p>
<pre><code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
</code></pre><p>HTML 4.01 Frameset</p>
<pre><code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;
</code></pre><p>HTML5 （向前向后兼容）</p>
<pre><code>&lt;!DOCTYPE html&gt;
</code></pre><p>DOCTYPE的作用：</p>
<ol>
<li><p>对文档进行有效性验证</p>
<p> 它告诉用户代理和校验器这个文档是按照什么 DTD 写的。这个动作是被动的，每次页面加载时，浏览器并不会下载 DTD 并检查合法性，只有当手动校验页面时才启用。</p>
</li>
<li><p>决定浏览器的呈现模式</p>
<p> 对于实际操作，通知浏览器读取文档时用哪种解析算法。如果没有写，则浏览器则根据自身的规则对代码进行解析，可能会严重影响 html 排版布局。浏览器有三种方式解析 HTML 文档。 <em> 非怪异（标准）模式 </em> 怪异模式 * 部分怪异（近乎标准）模式</p>
</li>
</ol>
<h2 id="charset"><a href="#charset" class="headerlink" title="charset"></a>charset</h2><p>申明文档使用的字符编码：</p>
<pre><code>&lt;meta charset=&quot;utf-8&quot;&gt;
</code></pre><p>等效写法:</p>
<pre><code>&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
</code></pre><h2 id="lang属性"><a href="#lang属性" class="headerlink" title="lang属性"></a>lang属性</h2><p>简体中文:</p>
<pre><code>&lt;html lang=&quot;zh-cmn-Hans&quot;&gt;
</code></pre><p>繁体中文:</p>
<pre><code>&lt;html lang=&quot;zh-cmn-Hant&quot;&gt;
</code></pre><h2 id="优先使用IE最新版本和Chrome"><a href="#优先使用IE最新版本和Chrome" class="headerlink" title="优先使用IE最新版本和Chrome"></a>优先使用IE最新版本和Chrome</h2><pre><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;
</code></pre><h2 id="360使用Google-Chrome-Frame"><a href="#360使用Google-Chrome-Frame" class="headerlink" title="360使用Google Chrome Frame"></a>360使用Google Chrome Frame</h2><pre><code>&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;
</code></pre><h2 id="百度禁止转码"><a href="#百度禁止转码" class="headerlink" title="百度禁止转码"></a>百度禁止转码</h2><p>百度移动搜索会自动为网页转码，贴上广告。</p>
<pre><code>&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; &gt;
</code></pre><h2 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h2><p>标题:</p>
<pre><code>&lt;title&gt;&lt;/title&gt;
</code></pre><p>页面关键词:</p>
<pre><code>&lt;meta name=&quot;keywords&quot; content=&quot;your keywords&quot;&gt;
</code></pre><p>页面描述内容:</p>
<pre><code>&lt;meta name=&quot;description&quot; content=&quot;your description&quot;&gt;
</code></pre><p>定义网页作者:</p>
<pre><code>&lt;meta name=&quot;author&quot; content=&quot;author,email address&quot;&gt;
</code></pre><p>定义网页搜索引擎索引方式，robotterms 是一组使用英文逗号「,」分割的值，通常有如下几种取值：none，noindex，nofollow，all，index和follow:</p>
<pre><code>&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;&gt;
</code></pre><h2 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h2><p>适应移动端显示:</p>
<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;
</code></pre><hr>
<p>参考：<a href="http://fex.baidu.com/blog/2014/10/html-head-tags/" target="_blank" rel="external">HTML head 头标签</a> </p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2016/04/27/JS中函数的四种调用方式及各自的this指向/" itemprop="url">
                  JS中函数的四种调用方式及各自的this指向
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-27T09:55:07+08:00" content="2016-04-27">
              2016-04-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/blog/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/blog/2016/04/27/JS中函数的四种调用方式及各自的this指向/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/27/JS中函数的四种调用方式及各自的this指向/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在javascript中函数一共有四种调用方式:函数调用模式、方法调用模式、构造器调用模式和apply调用模式。</p>
<p>this的指向会根据使用场合不同而不同，但总的来说，它指向调用函数的对象。</p>
<h2 id="函数调用模式"><a href="#函数调用模式" class="headerlink" title="函数调用模式"></a>函数调用模式</h2><pre><code>function f(){
    var value=1;
    console.log(this.value);
}

var value=2;
f();//2
</code></pre><p>此时this是指向全局对象global的，所以才会输出2。</p>
<h2 id="方法调用模式"><a href="#方法调用模式" class="headerlink" title="方法调用模式"></a>方法调用模式</h2><p>当一个函数被保存为一个对象的属性时，就称它为方法。</p>
<pre><code>var person = {
  name: &apos;xiaoming&apos;,
  sayName: function () {
  console.log(this.name);
  }
}
person.sayName();//&apos;xiaoming&apos;
</code></pre><p>此时this指向调用sayName()的对象person。</p>
<h2 id="构造器调用模式"><a href="#构造器调用模式" class="headerlink" title="构造器调用模式"></a>构造器调用模式</h2><p>通过new操作符调用一个函数，会创建一个链接到该函数的原型对象的对象，this指向这个新对象。</p>
<pre><code>function F(){
  this.value=1;
}
var value=2;
var o=new F();

console.log(o.value);//1
console.log(value);//2
</code></pre><p>this指向创建的新对象o,所以o.value值为1，value值没有改变。</p>
<h2 id="apply调用模式"><a href="#apply调用模式" class="headerlink" title="apply调用模式"></a>apply调用模式</h2><p>javascript中的函数也是对象，所以可以拥有方法。</p>
<p>apply()可以改变函数的调用对象，它接收两个参数：第一个为调用该函数的对象(要绑定给this的值),第二个为参数数组。</p>
<pre><code>function f() {
  this.value = 1;
}
var value = 2;
var o = {
    method: f
};

console.log(value);//2
o.method.apply();//apply()的参数为空时，默认调用全局对象。
console.log(value);//1

o.method.apply(o);//指向了对象o
console.log(o.value);//1
</code></pre>
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2016/04/26/什么是BFC/" itemprop="url">
                  什么是BFC
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-26T12:02:21+08:00" content="2016-04-26">
              2016-04-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/blog/categories/css/" itemprop="url" rel="index">
                    <span itemprop="name">css</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/blog/2016/04/26/什么是BFC/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/26/什么是BFC/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="BFC的定义"><a href="#BFC的定义" class="headerlink" title="BFC的定义"></a>BFC的定义</h2><p>BFC(Block formatting context)块级格式化上下文。它是一个独立的渲染区域，规定了内部元素如何布局，并且不会影响到外部元素。</p>
<p>formatting context:W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。</p>
<p>BFC布局规则：</p>
<ol>
<li>内部的box会在垂直方向，一个接一个地放置</li>
<li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li>
<li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此</li>
<li>BFC的区域不会与float box重叠</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此</li>
<li>计算BFC的高度时，浮动元素也参与计算</li>
</ol>
<h2 id="如何生成BFC"><a href="#如何生成BFC" class="headerlink" title="如何生成BFC"></a>如何生成BFC</h2><ul>
<li>根元素</li>
<li>float属性不为none</li>
<li>position:absolute/fixed</li>
<li>display:inline-block/table-cell/table-caption/flex/inline-flex</li>
<li>overflow不为visible</li>
</ul>
<h2 id="BFC的运用"><a href="#BFC的运用" class="headerlink" title="BFC的运用"></a>BFC的运用</h2><p>1.防止margin重叠</p>
<p>当两个或更多box垂直外边距相遇时，它们将形成一个外边距。这个外边距的高度等于两个外边距中的较大者。这就是外边距叠加。</p>
<p>正如规则2所说:</p>
<blockquote>
<p>2.Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</p>
</blockquote>
<p><img src="http://7xsthh.com2.z0.glb.clouddn.com/0426-5.png" alt=""></p>
<p>pink box的下外边距为50px,blue box的上外边距为50px.因为margin重叠，所以两个box的相距50px。如果不想它们重叠呢？让他们属于不同BFC即可。</p>
<p>2.清除浮动</p>
<pre><code>&lt;style&gt;
   .page{
        width: 480px;
        margin: 0 auto;
        border: 1px solid #eee;
   }
   .aside{
        width: 200px;
        height: 100px;
        background-color: #FFC0CB;
        float: left;
    }
    .main{
        height: 400px;
        background-color: rgba(0,0,255,0.5);
    }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;page&quot;&gt;
    &lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;    
&lt;/div&gt;
&lt;/body&gt;
</code></pre><p><img src="http://7xsthh.com2.z0.glb.clouddn.com/0426-1.png" alt=""></p>
<p>以上满足规则3</p>
<blockquote>
<p>3.每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此</p>
</blockquote>
<p>当我们给main运用overflow:hidden;后</p>
<p><img src="http://7xsthh.com2.z0.glb.clouddn.com/0426-2.png" alt=""></p>
<p>显然这是一个清除浮动效果。满足规则4</p>
<blockquote>
<p>4.BFC的区域不会与float box重叠</p>
</blockquote>
<p>我们都知道，当aside,main都浮动时，父元素会塌陷。</p>
<p><img src="http://7xsthh.com2.z0.glb.clouddn.com/0426-3.png" alt=""></p>
<p>给page运用:overflow:hidden;也清除浮动了</p>
<p><img src="http://7xsthh.com2.z0.glb.clouddn.com/0426-4.png" alt=""></p>
<p>满足规则6：</p>
<blockquote>
<p>6.计算BFC的高度时，浮动元素也参与计算</p>
</blockquote>
<hr>
<p>参考：<a href="http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html" target="_blank" rel="external">BFC 神奇背后的原理</a></p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2016/04/24/学习javascript闭包/" itemprop="url">
                  学习javascript闭包
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-24T10:30:50+08:00" content="2016-04-24">
              2016-04-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/blog/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/blog/2016/04/24/学习javascript闭包/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/24/学习javascript闭包/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>闭包是指有权访问另一个函数作用域中的变量的函数。</p>
<h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>两种变量的作用域：全局变量和局部变量</p>
<p>函数内部可以访问全局变量：</p>
<p><img src="http://7xsthh.com2.z0.glb.clouddn.com/0424-1.png" alt=""></p>
<p>反之函数外部无法访问函数内部的局部变量：<br><img src="http://7xsthh.com2.z0.glb.clouddn.com/0424-2.png" alt=""></p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><img src="http://7xsthh.com2.z0.glb.clouddn.com/0424-3.png" alt=""></p>
<p>以上代码实现了在函数外部访问函数的局部变量。其中f2函数就是闭包。</p>
<p>f2可以访问f1的局部变量a,但反过来f1却无法访问f2中的变量，这其实就是JS中的作用域链。<br>子对象可以一级一级的向上查找父对象的变量，反之父对象不能向下查找。</p>
<h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><p>闭包除了可以访问函数内部的局部变量之外，还会将这些变量保存下来。</p>
<p>这意味着在闭包的父函数调用之后，这些被保存的变量不会被销毁。闭包使用过多会影响网页的性能，IE浏览器有时会产生内存泄漏。解决方案：对于不需要使用的局部变量进行手动清除。</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2016/04/23/初探原型和原型链/" itemprop="url">
                  初探原型和原型链
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-23T15:08:55+08:00" content="2016-04-23">
              2016-04-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/blog/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/blog/2016/04/23/初探原型和原型链/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/23/初探原型和原型链/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>在JS中我们创建的每一个函数都有一个prototype属性，该属性是一个指针，指向该函数的原型对象。</p>
<p>我们通常这样使用原型：</p>
<p><img src="http://7xsthh.com2.z0.glb.clouddn.com/0423-1.png" alt=""></p>
<p>第一行代码创建了一个构造函数，第二行在Person的原型对象中定义了一个sayName()方法。<br>接着创建了Person的两个实例person1和person2，他们共用同一个方法sayName()。</p>
<p>图解：</p>
<p><img src="http://7xsthh.com2.z0.glb.clouddn.com/0423-2.png" alt=""></p>
<p>这样做的好处是：不同对象在使用同一功能的方法时不用重复创建方法，还具有良好的封装性。</p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>javascript没有类，它的继承是使用原型链来实现的。</p>
<p><img src="http://7xsthh.com2.z0.glb.clouddn.com/0423-3.png" alt=""></p>
<p>首先定义了两个对象Person和Animal，它们有各自的属性以及定义在原型对象上的方法。<br>重点是Animal继承了Person,这个继承是通过创建Person的实例，然后将该实例赋给Animal的<br>原型对象实现的（Animal.prototype=new Person();）。<strong>本质是重写原型对象</strong>。在确定<br>继承关系之后，又给Animal.prototype定义了一个新方法howl(),这样就在继承Person的属性和方法上添加了一个新方法。</p>
<p>图解：</p>
<p><img src="http://7xsthh.com2.z0.glb.clouddn.com/0423-4.png" alt=""></p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2016/04/22/JS的基本包装类型/" itemprop="url">
                  JS的基本包装类型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-22T21:50:34+08:00" content="2016-04-22">
              2016-04-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/blog/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/blog/2016/04/22/JS的基本包装类型/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/22/JS的基本包装类型/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ECMAScript提供了3个特殊的引用类型：Boolean、Number、String。</p>
<p>操作字符串时，我们通常这样做：</p>
<p><img src="http://7xsthh.com2.z0.glb.clouddn.com/0422-1.png" alt=""></p>
<p>在上面的例子中，将字符串”Hello World.”赋给了str1，然后调用了str1的substring()方法，<br>最后把返回的结果保存在str2中。</p>
<p>str1保存了一个字符串，字符串是基本类型值，没有方法，但我们这里却调用了一个方法，还成功了。这是怎么回事呢？</p>
<p>实际上，当执行str1.substring(5)时，后台要访问str1的值（从内存中读取这个值），此时后台会这样处理：</p>
<p><img src="http://7xsthh.com2.z0.glb.clouddn.com/0422-2.png" alt=""></p>
<ol>
<li>创建String类型的一个实例</li>
<li>在实例上调用指定的方法</li>
<li>销毁这个实例</li>
</ol>
<p>通过这个过程就实现了“字符串像对象一样使用方法”.(Boolean、Number类型是同样的道理)</p>
<p>基本包装类型不同于引用类型，对象的生存周期极短,不能动态添加属性和方法。上面例子中，str1对象调用了substring方法后就被销毁了（销毁的只是新建的实例，没有销毁基本类型值）。再举个例子:</p>
<p><img src="http://7xsthh.com2.z0.glb.clouddn.com/0422-3.png" alt=""></p>
<p>str1.color给str1添加了一个color属性，且成功了，之后str1对象被销毁。最后一行代码要输出str1的color属性的值，得到的结果是undefined。这是因为再次访问str1时，又创建了一个String对象，而这个新对象没有color属性。</p>
<p>基本包装类型给我们操作基本类型值提供了便利。</p>
<p><strong>注意</strong>：如果使用new操作符创建对象，此时是引用类型。</p>
<p><img src="http://7xsthh.com2.z0.glb.clouddn.com/0422-4.png" alt=""></p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2016/04/20/JS的执行环境及作用域/" itemprop="url">
                  JS的执行环境及作用域
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-20T09:37:42+08:00" content="2016-04-20">
              2016-04-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/blog/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/blog/2016/04/20/JS的执行环境及作用域/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/20/JS的执行环境及作用域/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="执行环境-execution-context"><a href="#执行环境-execution-context" class="headerlink" title="执行环境(execution context)"></a>执行环境(execution context)</h2><p>执行环境（又叫执行上下文）：定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的<strong>变量对象</strong>，环境中定义的所有变量和函数都保存在这个对象中。</p>
<p>执行环境的销毁：某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量<br>和函数定义也随之销毁。</p>
<p>在web浏览器中，全局执行环境被认为是window对象。每个函数都有自己的执行环境。</p>
<p>执行环境栈：当浏览器载入javascript文件后，最先进入栈的是全局执行环境。在全局执行环境中调用函数时，执行流进入该函数内，函数的环境被压入栈中。执行完毕后，将该环境弹出，控制权给之前的执行环境。通过这个过程，堆栈中的环境就会被依次执行并且弹出堆栈，直到回到全局环境。</p>
<p>结论：一个执行的环境可以抽象的理解为object（this的值）。每个执行的环境主要有三个属性：变量对象、this、作用域链。</p>
<h2 id="作用域和作用域链-scope-chain"><a href="#作用域和作用域链-scope-chain" class="headerlink" title="作用域和作用域链(scope chain)"></a>作用域和作用域链(scope chain)</h2><blockquote>
<p>ECMA262这样描述：</p>
<ul>
<li>任何执行环境时刻的作用域，都是由作用域链来实现。</li>
<li>在一个函数被定义的时候，会将他定义时刻的作用域链链接到这个函数对象的[[scope]]属性。</li>
<li>在一个函数对象被调用的时候，会创建一个活动对象(也就是一个对象), 然后对于每一个函数的形参，都命名为该活动对象的命名属性, 然后将这个活动对象做为此时的作用域链(scope chain)最前端, 并将这个函数对象的[[scope]]加入到scope chain中.</li>
</ul>
</blockquote>
<p>作用域链的用途：保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码<br>所在环境的变量对象。</p>
<pre><code>var color=&apos;blue&apos;;
function changeColor(){
    var anotherColor=&apos;red&apos;;
    function swapColors(){
        var tempColor=anotherColor;
        anotherColor=color;
        color=tempColor;
        //这里可以访问color,anotherColor,tempColor
}
    //这里可以访问color,anotherColor,但不能访问tempColor
    swapColors();
}
//这里只能访问color
changeColor();
</code></pre><p>以上代码涉及三个执行环境：全局环境、changeColor()的局部环境、swapColors()的局部环境。</p>
<p>作用域链为：</p>
<p><img src="http://7xsthh.com2.z0.glb.clouddn.com/scope-chain.jpg" alt="作用域链"></p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="extend next" rel="next" href="/blog/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/blog/uploads/wo.png"
               alt="刘定源" />
          <p class="site-author-name" itemprop="name">刘定源</p>
          <p class="site-description motion-element" itemprop="description">眼睛和大脑</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/blog/archives">
              <span class="site-state-item-count">13</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/blog/categories">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/liudingyuan" target="_blank">
                  
                    <i class="fa fa-globe"></i>
                  
                  github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/3840084784" target="_blank">
                  
                    <i class="fa fa-globe"></i>
                  
                  weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘定源</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/blog/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/blog/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/blog/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/blog/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/blog/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/blog/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=0.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"ldy-blog"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
      <script src="/blog/vendors/ua-parser-js/dist/ua-parser.min.js"></script>
      <script src="/blog/js/src/hook-duoshuo.js"></script>
    
  





  
  
  

  

  

</body>
</html>
